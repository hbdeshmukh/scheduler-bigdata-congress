% !TEX root = scheduler.tex
\section{Background}\label{sec:background}
In this section we introduce aspects about \sys{} that are needed to 
describe the proposed scheduler framework.

\sys{} is a relational database engine 
% and SQL as its query language.  \sys{} 
designed to efficiently leverage contemporary hardware aspects such as large main memory, multi-core, and multi-socket server settings. 
The system aims to deliver high performance in read-mostly data warehousing 
environments.  
While \sys{} targets environments in which datasets are mostly memory resident, it can also answer queries on datasets that do not fit in memory, as all the data are accessed via a buffer pool, that supports page evictions and replacements. 
% However,  the implementation of \sys{} largely targets settings in which the  entire 
%database fits in memory.

The control flow associated with query execution in \sys{} involves 
parsing the query, and then optimizing the query using a cost-based query 
optimizer.
The optimized query plan is represented as a Directed Acyclic 
Graph (DAG) of relational operator primitives. 
Currently, the system employs hash-based implementation for join and aggregate operators. 

The query plan DAG is then sent to a \textit{scheduler}, which is the focus of this paper. 
The scheduler runs as a separate thread and coordinates the execution of all queries. 
In addition to the scheduler, the database engine has a pool of worker 
threads, where the computations on the data are carried out. 
% Commenting this line as it is repeated in thread model section. 
%All workers read and write data from a buffer pool, that is managed by a storage manager. 

\sys{} uses a query execution paradigm (built using previously proposed approaches~\cite{qsstorage,morsel}) in which a query is executed as a sequence of \textit{work orders}. 
A work order operates on a data block, which is treated as a self-contained mini-database~\cite{qsstorage}. 
The computation that is required for each operator in a query plan is decomposed into a sequence of work orders. 
For example, a select operator produces as many work orders as there are blocks in the input table. 
Next, we describe the storage management in \sys{}.

\subsection{Storage Management in \sys{}}\label{ssec:storage-manager}
Data organization in the \sys{} storage manager holds the key to intra-query 
parallelism~\cite{qsstorage}. 
Data in a relation are organized in the form of blocks. 
Each block holds a collection of tuples from a single table. 
A unique aspect of the storage organization in \sys{} is that blocks are considered to 
be independent and self-contained mini-databases. 
Thus, when creating an index, instead of creating a global index with 
``pointers'' to the tuples in blocks, the index fragments are stored within the blocks. 
Each block is internally organized into \textit{sub-blocks}. 
There is one \textit{tuple storage sub-block}, which could be in a row store or a 
column store format.
%\reminder{Should we add more formats like compressed column store etc?}. 
In addition, each block has one sub-block for each index created on the table. 
CSB+-tree~\cite{csb+-tree} and BitWeaving~\cite{bitweaving} 
indices are currently supported. 
The blocks are free to self-organize themselves and thus a given table may have blocks in different formats. 
For example, new blocks in a table may be in a row store format, while older blocks may 
be in a column store format.
%The block size is configurable %(in fact blocks in the same table can be of 
%%different sizes), %and the recommended block size is 4 MB.

This storage block design, as articulated earlier in~\cite{qsstorage} enables the query execution to be broken down into a set of independent tasks on each block. 
This is a crucial aspect that we leverage in the design of our scheduler. 

% Note(harshad) - The following paragraph seems too much information, hence removing it. 
%The storage manager also contains a \textit{buffer pool manager}. 
%It organizes the memory as an array of slots, and overlays blocks on top of the slots (so block sizes are constrained to be a multiple of the underlying slot size). 
%Memory allocations for data blocks for \textit{both} permanent and temporary tables are always made from a centralized buffer pool. 
%In addition, all allocations for run-time data structures, such as hash tables are also made 
%by the buffer pool. 
%The buffer pool manager employs an LRU-2~\cite{lruk} replacement policy. 
%Thus, it is possible for a hash table to get evicted to disk, if it has become ``cold''; e.g. if it belongs to a suspended query.